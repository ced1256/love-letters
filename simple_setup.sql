-- This is a simple setup script for your database.
-- It only includes what's necessary for a username/password login system.

-- STEP 1: Enable crypto extension for passwords.
CREATE EXTENSION IF NOT EXISTS pgcrypto;

-- STEP 2: Clean up old tables and functions if they exist.
DROP TABLE IF EXISTS "public"."letters" CASCADE;
DROP TABLE IF EXISTS "public"."users" CASCADE;
DROP FUNCTION IF EXISTS "public"."login"(text, text);
DROP FUNCTION IF EXISTS "public"."register_user"(text, text);

-- STEP 3: Create the users table.
-- 'username' has a UNIQUE constraint, as you requested.
CREATE TABLE "public"."users" (
    "id" uuid NOT NULL DEFAULT gen_random_uuid() PRIMARY KEY,
    "username" text NOT NULL UNIQUE,
    "password_hash" text NOT NULL,
    "created_at" timestamp with time zone NOT NULL DEFAULT now()
);

-- STEP 4: Create the letters table.
-- It links to the users table via 'user_id'.
CREATE TABLE "public"."letters" (
    "id" bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    "user_id" uuid NOT NULL REFERENCES public.users(id) ON DELETE CASCADE,
    "title" text,
    "content" text,
    "author" text,
    "created_at" timestamp with time zone DEFAULT now() NOT NULL
);

-- STEP 5: Create a function to register new users.
-- This function includes the constraints you requested.
CREATE OR REPLACE FUNCTION public.register_user(
    p_username text,
    p_password text
)
RETURNS json
LANGUAGE plpgsql
AS $$
BEGIN
    -- Constraint 1: Username cannot contain spaces.
    IF p_username ~ '\s' THEN
        RETURN json_build_object('success', false, 'message', 'Username cannot contain spaces.');
    END IF;

    -- Constraint 2: Username must be unique.
    -- The UNIQUE constraint on the table already handles this, but this provides a friendlier error message.
    IF EXISTS (SELECT 1 FROM public.users WHERE username = p_username) THEN
        RETURN json_build_object('success', false, 'message', 'Username is already taken.');
    END IF;

    -- If constraints pass, insert the new user.
    INSERT INTO public.users (username, password_hash)
    VALUES (p_username, crypt(p_password, gen_salt('bf')));
    
    RETURN json_build_object('success', true);
END;
$$;

-- STEP 6: Create a function to log users in.
-- This checks the provided password against the stored hash.
CREATE OR REPLACE FUNCTION public.login(
    p_username text,
    p_password text
)
RETURNS TABLE(user_id uuid, username text)
LANGUAGE plpgsql
AS $$
BEGIN
    RETURN QUERY
    SELECT u.id, u.username
    FROM public.users u
    WHERE u.username = p_username AND u.password_hash = crypt(p_password, u.password_hash);
END;
$$;

-- STEP 7: Enable Row Level Security (RLS).
-- This is a Supabase security feature. We will set a simple "allow all" policy
-- because our application's security is handled by the 'login' function.
ALTER TABLE public.users ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.letters ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Public access for users" ON "public"."users" FOR ALL USING (true);
CREATE POLICY "Public access for letters" ON "public"."letters" FOR ALL USING (true); 